# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/10_xml.ipynb.

# %% auto 0
__all__ = ['re_tag', 'get_namespaces', 'split_namespace_tag', 'get_entries', 'get_deleted_entries', 'deleted_to_series',
           'set_or_append', 'entry_to_dict', 'entry_to_series', 'to_df', 'to_curated_df', 'columns_depth']

# %% ../nbs/10_xml.ipynb 2
import pathlib
import re
import datetime
from collections.abc import Iterable

import numpy as np
import pandas as pd
from lxml import etree

import sproc.structure
import sproc.postprocess

# %% ../nbs/10_xml.ipynb 13
def get_namespaces(
    input_file: str | pathlib.Path, # XML file
    root_name: str = 'base' # Name of the root element
    ) -> dict[str, str]: # Mapping from *tag* to *namespace*
    "Returns the namespaces in the input XML file"
    
    tree = etree.parse(input_file)
    
    namespaces = tree.getroot().nsmap
    
    if None in namespaces:
        
        namespaces[root_name] = namespaces.pop(None)
        
    return namespaces

# %% ../nbs/10_xml.ipynb 16
re_tag = re.compile('\{(.*)\}(.*)')

# %% ../nbs/10_xml.ipynb 20
def split_namespace_tag(
    namespace_tag: str # Input
    ) -> tuple[str]: # Namespace and tag
    'Splits a hierarchical "address" in an XML file into *namespace* and *tag*'
    
    return re_tag.match(namespace_tag).groups()

# %% ../nbs/10_xml.ipynb 26
def get_entries(
    root: etree.Element # XML root
    ) -> list[etree.Element]: # Entries
    "Returns all the entries hanging from the input"
    
    return [e for e in root if split_namespace_tag(e.tag)[1] == 'entry']

# %% ../nbs/10_xml.ipynb 37
def get_deleted_entries(
    root: etree.Element # XML root
    ) -> list[etree.Element]: # *Deleted* entries
    "Returns all the *deleted* entries hanging from the input"
    
    return [e for e in root if split_namespace_tag(e.tag)[1] == 'deleted-entry']

# %% ../nbs/10_xml.ipynb 43
def deleted_to_series(
    input_file: str | pathlib.Path # XML file
) -> pd.Series: # A Pandas Series with XML data
    "Reads and parses 'deleted' entries in an XML file."
    
    tree = etree.parse(input_file)
    root = tree.getroot()
    
    ids = []
    dates = []

    for e in get_deleted_entries(root):
        ids.append(e.attrib['ref'])
        # dates.append(pd.to_datetime(e.attrib['when']))
        dates.append(pd.to_datetime(e.attrib['when'], utc=True))
        
    name = 'deleted_on'
        
    if not ids:
        
        return pd.Series([], dtype='datetime64[ns]', name=name)
    
    else:

        return pd.Series(data=dates, index=ids, name=name)

# %% ../nbs/10_xml.ipynb 51
def set_or_append(
    d: dict, # Input (to be modified)
    key: str, # Entry of the dictionary to be created/extended
    value: str | dict # Value to be set/added
    ) -> None:
    "Set or append a new element to the dictionary storing the data in a single entry"

    # if there is already something in the given `key`...
    if key in d:

        # if what is already there is a list...
        if type(d[key]) == list:

            # ...and so is the `value` to be added...
            if isinstance(value, list):

                # ...whatever came before and was not a list is turned into (a single-element) one
                d[key] = [e if isinstance(e, list) else [e] for e in d[key]] + [value]

            # if what is going to be added is NOT a list
            else:

                # if what is there is actually a list of lists...
                if isinstance(d[key][0], list):

                    # ...the new `value` is turned into a (singleton)
                    d[key].append([value])

                # if what is there is a (plain) list of scalars (and so is `value`)...
                else:
            
                    d[key].append(value)
        
        # if what is already there is NOT a list...
        else:

            # ...we make one, but...

            # ...if the new element is a list...
            if isinstance(value, list):

                # ...whatever scalar was there is turned into a (single-element) list inside the new list
                d[key] = [[d[key]]]

            else:

                # whatever was there becomes the 1st element in a new list
                d[key] = [d[key]]

            # the `value` is finally added
            d[key].append(value)
    
    # if there is nothing for the given `key`...
    else:

        # if `value` is a list AND of scalars...
        if isinstance(value, list) and not isinstance(value[0], list):

            # in order to play it safe, the list is assumed to be just one element in a sequence
            d[key] = [value]

        # if the `value` is not a list OR it IS a list of lists...
        else:

            d[key] = value

    # if the *final* value is a list...
    if isinstance(d[key], list):

        # "double lists" ([[]]) are turned into simple lists
        d[key] = [e[0] if (isinstance(e, list) and (len(e) == 1) and isinstance(e[0], list)) else e  for e in d[key]]

            

# %% ../nbs/10_xml.ipynb 61
def entry_to_dict(
    entry: etree.Element, # XML entry
    recursive: bool = True # If `True`, children of `entry` are also parsed
    ) -> dict:
    "Parse an XML entry into a Python dictionary"

    res = {}
    
    # for every "child" of `entry` ...
    for e in entry:
        
        # ...the *namespace* and *tag* are extracted
        namespace, tag = split_namespace_tag(e.tag)
        
        # for the sake of readability
        value = e.text
            
        # if `value` is "something" and not an empty string after striping it of blank characters...
        if value and (value.strip() != ''):
            
            # if the text contains a number...
            if value.isnumeric():
                
                # ...it is turned into a `float`
                value = float(value)
                
                # if the latter is actually an integer...
                if value.is_integer():
                    
                    # ...conversion is performed
                    value = int(value)
            
            # assert tag not in res, f'multiple values for {tag}'
            
            # the value of this element (whether the original text or the obtained number) is stored
            set_or_append(res, tag, value)
        
        # if in "recursive mode" and this element has children (`len(e)` is different from 0)...
        if recursive and len(e):
            
            # recursion
            sub_res = entry_to_dict(e)
            
            for k, v in sub_res.items():
                
                # the name of the new "key" is assembled from those of the parent and the child
                key_name = f'{tag}{sproc.structure.nested_tags_separator}{k}'
                
                set_or_append(res, key_name, v)
    
    return res

# %% ../nbs/10_xml.ipynb 68
def entry_to_series(
    entry: etree.Element # Input
    ) -> pd.Series: # Output
    "Turns an XML element into a Pandas' series"

    return pd.Series(entry_to_dict(entry))

# %% ../nbs/10_xml.ipynb 77
def to_df(
    input_file: str | pathlib.Path # XML file
) -> pd.DataFrame: # Data in tabular format
    "Reads and parses an XML file into a `pd.DataFrame`"
    
    tree = etree.parse(input_file)
    root = tree.getroot()
    entries = get_entries(root)

    # if the input file was empty....
    if not entries:

        print(f'no entries were found in {input_file.name}')

        return pd.DataFrame()

    # if the the input file was NOT empty
    else:
    
        return pd.concat([entry_to_series(e) for e in entries], axis=1).T

# %% ../nbs/10_xml.ipynb 80
def to_curated_df(
    input_file: str | pathlib.Path # Input file
    ) -> pd.DataFrame: # A Pandas DataFrame with XML data
    "Reads, parses and tidies up an XML file into a `pd.DataFrame`"

    raw_df = to_df(input_file)

    # if the input file was empty....
    if raw_df.empty:

        return raw_df
    
    # if the the input file was NOT empty
    else:
    
        return sproc.postprocess.typecast_columns(raw_df)

# %% ../nbs/10_xml.ipynb 86
def columns_depth(
    df: pd.DataFrame # Input
    ) -> pd.Series: # Depths
    "Returns the depth, inside the original XML, of every column"

    n_nestings = df.columns.str.extractall(f'(\\S{sproc.structure.nested_tags_separator}\\S)')
    n_nestings.index.names = ['column', 'match']
    
    return n_nestings[0].groupby('column').size()
